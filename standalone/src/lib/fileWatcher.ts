import * as fs from 'fs'
import * as path from 'path'
import type { AgentState } from './types'
import { cancelWaitingTimer, cancelPermissionTimer, clearAgentActivity } from './timerManager'
import { processTranscriptLine } from './transcriptParser'
import { broadcast } from './wsManager'
import { FILE_WATCHER_POLL_INTERVAL_MS, PROJECT_SCAN_INTERVAL_MS } from './constants'

export function startFileWatching(
  agentId: number,
  filePath: string,
  agents: Map<number, AgentState>,
  fileWatchers: Map<number, fs.FSWatcher>,
  pollingTimers: Map<number, ReturnType<typeof setInterval>>,
  waitingTimers: Map<number, ReturnType<typeof setTimeout>>,
  permissionTimers: Map<number, ReturnType<typeof setTimeout>>,
): void {
  // Primary: fs.watch
  try {
    const watcher = fs.watch(filePath, () => {
      readNewLines(agentId, agents, waitingTimers, permissionTimers)
    })
    fileWatchers.set(agentId, watcher)
  } catch (e) {
    console.log(`[Pixel Agents] fs.watch failed for agent ${agentId}: ${e}`)
  }

  // Backup: poll every 2s
  const interval = setInterval(() => {
    if (!agents.has(agentId)) { clearInterval(interval); return }
    readNewLines(agentId, agents, waitingTimers, permissionTimers)
  }, FILE_WATCHER_POLL_INTERVAL_MS)
  pollingTimers.set(agentId, interval)
}

export function readNewLines(
  agentId: number,
  agents: Map<number, AgentState>,
  waitingTimers: Map<number, ReturnType<typeof setTimeout>>,
  permissionTimers: Map<number, ReturnType<typeof setTimeout>>,
): void {
  const agent = agents.get(agentId)
  if (!agent) return
  try {
    const stat = fs.statSync(agent.jsonlFile)
    if (stat.size <= agent.fileOffset) return

    const buf = Buffer.alloc(stat.size - agent.fileOffset)
    const fd = fs.openSync(agent.jsonlFile, 'r')
    fs.readSync(fd, buf, 0, buf.length, agent.fileOffset)
    fs.closeSync(fd)
    agent.fileOffset = stat.size

    const text = agent.lineBuffer + buf.toString('utf-8')
    const lines = text.split('\n')
    agent.lineBuffer = lines.pop() || ''

    const hasLines = lines.some(l => l.trim())
    if (hasLines) {
      // New data arriving -- cancel timers (data flowing means agent is still active)
      cancelWaitingTimer(agentId, waitingTimers)
      cancelPermissionTimer(agentId, permissionTimers)
      if (agent.permissionSent) {
        agent.permissionSent = false
        broadcast({ type: 'agentToolPermissionClear', id: agentId })
      }
    }

    for (const line of lines) {
      if (!line.trim()) continue
      processTranscriptLine(agentId, line, agents, waitingTimers, permissionTimers)
    }
  } catch (e) {
    console.log(`[Pixel Agents] Read error for agent ${agentId}: ${e}`)
  }
}

export function ensureProjectScan(
  projectDir: string,
  knownJsonlFiles: Set<string>,
  projectScanTimerRef: { current: ReturnType<typeof setInterval> | null },
  activeAgentIdRef: { current: number | null },
  nextAgentIdRef: { current: number },
  agents: Map<number, AgentState>,
  fileWatchers: Map<number, fs.FSWatcher>,
  pollingTimers: Map<number, ReturnType<typeof setInterval>>,
  waitingTimers: Map<number, ReturnType<typeof setTimeout>>,
  permissionTimers: Map<number, ReturnType<typeof setTimeout>>,
  persistAgents: () => void,
): void {
  if (projectScanTimerRef.current) return
  // Seed with all existing JSONL files so we only react to truly new ones
  try {
    const files = fs.readdirSync(projectDir)
      .filter(f => f.endsWith('.jsonl'))
      .map(f => path.join(projectDir, f))
    for (const f of files) {
      knownJsonlFiles.add(f)
    }
  } catch { /* dir may not exist yet */ }

  projectScanTimerRef.current = setInterval(() => {
    scanForNewJsonlFiles(
      projectDir, knownJsonlFiles, activeAgentIdRef, nextAgentIdRef,
      agents, fileWatchers, pollingTimers, waitingTimers, permissionTimers,
      persistAgents,
    )
  }, PROJECT_SCAN_INTERVAL_MS)
}

function scanForNewJsonlFiles(
  projectDir: string,
  knownJsonlFiles: Set<string>,
  activeAgentIdRef: { current: number | null },
  _nextAgentIdRef: { current: number },
  agents: Map<number, AgentState>,
  fileWatchers: Map<number, fs.FSWatcher>,
  pollingTimers: Map<number, ReturnType<typeof setInterval>>,
  waitingTimers: Map<number, ReturnType<typeof setTimeout>>,
  permissionTimers: Map<number, ReturnType<typeof setTimeout>>,
  persistAgents: () => void,
): void {
  let files: string[]
  try {
    files = fs.readdirSync(projectDir)
      .filter(f => f.endsWith('.jsonl'))
      .map(f => path.join(projectDir, f))
  } catch { return }

  for (const file of files) {
    if (!knownJsonlFiles.has(file)) {
      knownJsonlFiles.add(file)
      if (activeAgentIdRef.current !== null) {
        // Active agent focused -> /clear reassignment
        console.log(`[Pixel Agents] New JSONL detected: ${path.basename(file)}, reassigning to agent ${activeAgentIdRef.current}`)
        reassignAgentToFile(
          activeAgentIdRef.current, file,
          agents, fileWatchers, pollingTimers, waitingTimers, permissionTimers,
          persistAgents,
        )
      }
      // No active agent and no VS Code terminal adoption in standalone -- skip
    }
  }
}

export function reassignAgentToFile(
  agentId: number,
  newFilePath: string,
  agents: Map<number, AgentState>,
  fileWatchers: Map<number, fs.FSWatcher>,
  pollingTimers: Map<number, ReturnType<typeof setInterval>>,
  waitingTimers: Map<number, ReturnType<typeof setTimeout>>,
  permissionTimers: Map<number, ReturnType<typeof setTimeout>>,
  persistAgents: () => void,
): void {
  const agent = agents.get(agentId)
  if (!agent) return

  // Stop old file watching
  fileWatchers.get(agentId)?.close()
  fileWatchers.delete(agentId)
  const pt = pollingTimers.get(agentId)
  if (pt) { clearInterval(pt) }
  pollingTimers.delete(agentId)

  // Clear activity
  cancelWaitingTimer(agentId, waitingTimers)
  cancelPermissionTimer(agentId, permissionTimers)
  clearAgentActivity(agent, agentId, permissionTimers)

  // Swap to new file
  agent.jsonlFile = newFilePath
  agent.fileOffset = 0
  agent.lineBuffer = ''
  persistAgents()

  // Start watching new file
  startFileWatching(agentId, newFilePath, agents, fileWatchers, pollingTimers, waitingTimers, permissionTimers)
  readNewLines(agentId, agents, waitingTimers, permissionTimers)
}
